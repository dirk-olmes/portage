From 118fee4d6b840040d465627eeb54d862bb251c14 Mon Sep 17 00:00:00 2001
From: Mark Stemm <mark.stemm@sysdig.com>
Date: Wed, 10 May 2017 15:35:29 -0700
Subject: [PATCH] Handle netlink sockets (#809)

* Minimal support for NETLINK sockets.

Add minimal support for AF_NETLINK sockets, with the new type
SCAP_FD_NETLINK. This is mostly done so they are not mixed up with
SCAP_FD_UNKNOWN sockets, which are not expected to be in scap files at
all.

The type is used when first parsing a fd from its fd num/domain num in
sinsp_parser::add_socket or when parsing /proc/net/netlink in
scap_fd_read_netlink_sockets_from_proc_fs(). After that, the type is
copied when converting from scap_fdinfos to sinsp_fdinfos in
sinsp_threadinfo::add_fd_from_scap.

There is limited support for displaying information on netlink fds. The
typechar is 'n', the typestring is "netlink"/"<NETLINK>", and they don't
have any additional information or a category for them.

* Improve handling of potentially unknown fds.

Ensure we better handle fds that can't be mapped to a specific
scap_fd_type.

When reading a descriptor from a scap file, ignore SCAP_FD_UNKNOWN
sockets and don't return an error. When writing a descriptor to a scap
file, skip SCAP_FD_UNKNOWN descriptors.

When parsing a socket fd, if we don't map a type log an error but continue.
---
 userspace/libscap/scap.h          |   3 +-
 userspace/libscap/scap_fds.c      | 158 ++++++++++++++++++++++++++++++++++++++
 userspace/libscap/scap_savefile.c |   3 +-
 userspace/libsinsp/event.cpp      |   1 +
 userspace/libsinsp/fdinfo.cpp     |   4 +
 userspace/libsinsp/fdinfo.h       |   1 +
 userspace/libsinsp/parsers.cpp    |  18 ++++-
 userspace/libsinsp/threadinfo.cpp |   2 +
 8 files changed, 186 insertions(+), 4 deletions(-)

diff --git a/userspace/libscap/scap.h b/userspace/libscap/scap.h
index c9bb6247a..44a4a0aa3 100644
--- a/userspace/libscap/scap.h
+++ b/userspace/libscap/scap.h
@@ -122,7 +122,8 @@ typedef enum scap_fd_type
 	SCAP_FD_SIGNALFD = 11,
 	SCAP_FD_EVENTPOLL = 12,
 	SCAP_FD_INOTIFY = 13,
-	SCAP_FD_TIMERFD = 14
+	SCAP_FD_TIMERFD = 14,
+	SCAP_FD_NETLINK = 15
 }scap_fd_type;
 
 /*!
diff --git a/userspace/libscap/scap_fds.c b/userspace/libscap/scap_fds.c
index def0881dd..516e06568 100644
--- a/userspace/libscap/scap_fds.c
+++ b/userspace/libscap/scap_fds.c
@@ -150,6 +150,9 @@ int32_t scap_fd_info_to_string(scap_fdinfo *fdi, OUT char *str, uint32_t stlen)
  	case SCAP_FD_UNSUPPORTED:
  		snprintf(str, stlen, "<UNSUPPORTED>");
  		break;
+ 	case SCAP_FD_NETLINK:
+ 		snprintf(str, stlen, "<NETLINK>");
+ 		break;
 	default:
 		ASSERT(false);
 		return SCAP_FAILURE;
@@ -206,6 +209,7 @@ uint32_t scap_fd_info_len(scap_fdinfo *fdi)
 	case SCAP_FD_EVENTPOLL:
 	case SCAP_FD_INOTIFY:
 	case SCAP_FD_TIMERFD:
+	case SCAP_FD_NETLINK:
 		res += (uint32_t)strnlen(fdi->info.fname, SCAP_MAX_PATH_SIZE) + 2;    // 2 is the length field before the string
 		break;
 	default:
@@ -298,6 +302,7 @@ int32_t scap_fd_write_to_disk(scap_t *handle, scap_fdinfo *fdi, scap_dumper_t *d
 	case SCAP_FD_EVENTPOLL:
 	case SCAP_FD_INOTIFY:
 	case SCAP_FD_TIMERFD:
+	case SCAP_FD_NETLINK:
 		stlen = (uint16_t)strnlen(fdi->info.fname, SCAP_MAX_PATH_SIZE);
 		if(scap_dump_write(d, &stlen,  sizeof(uint16_t)) != sizeof(uint16_t) ||
 		        (stlen > 0 && scap_dump_write(d, fdi->info.fname, stlen) != stlen))
@@ -306,7 +311,12 @@ int32_t scap_fd_write_to_disk(scap_t *handle, scap_fdinfo *fdi, scap_dumper_t *d
 			return SCAP_FAILURE;
 		}
 		break;
+	case SCAP_FD_UNKNOWN:
+		// Ignore UNKNOWN fds without failing
+		ASSERT(false);
+		break;
 	default:
+		snprintf(handle->m_lasterr, SCAP_LASTERR_SIZE, "Unknown fdi type %d", fdi->type);
 		ASSERT(false);
 		return SCAP_FAILURE;
 	}
@@ -441,8 +451,12 @@ uint32_t scap_fd_read_from_disk(scap_t *handle, OUT scap_fdinfo *fdi, OUT size_t
 	case SCAP_FD_EVENTPOLL:
 	case SCAP_FD_INOTIFY:
 	case SCAP_FD_TIMERFD:
+	case SCAP_FD_NETLINK:
 		res = scap_fd_read_fname_from_disk(handle, fdi->info.fname,nbytes,f);
 		break;
+	case SCAP_FD_UNKNOWN:
+		ASSERT(false);
+		break;
 	default:
 		snprintf(handle->m_lasterr, SCAP_LASTERR_SIZE, "error reading the fd info from file, wrong fd type %u", (uint32_t)fdi->type);
 		return SCAP_FAILURE;
@@ -839,6 +853,143 @@ int32_t scap_fd_read_unix_sockets_from_proc_fs(scap_t *handle, const char* filen
 	return uth_status;
 }
 
+//sk       Eth Pid    Groups   Rmem     Wmem     Dump     Locks     Drops     Inode
+//ffff88011abfb000 0   0      00000000 0        0        0 2        0        13
+
+int32_t scap_fd_read_netlink_sockets_from_proc_fs(scap_t *handle, const char* filename, scap_fdinfo **sockets)
+{
+	FILE *f;
+	char line[1024];
+	int first_line = false;
+	char *delimiters = " \t";
+	char *token;
+	int32_t uth_status = SCAP_SUCCESS;
+
+	f = fopen(filename, "r");
+	if(NULL == f)
+	{
+		ASSERT(false);
+		return SCAP_FAILURE;
+	}
+	while(NULL != fgets(line, sizeof(line), f))
+	{
+		// skip the first line ... contains field names
+		if(!first_line)
+		{
+			first_line = true;
+			continue;
+		}
+		scap_fdinfo *fdinfo = malloc(sizeof(scap_fdinfo));
+		memset(fdinfo, 0, sizeof(scap_fdinfo));
+		fdinfo->type = SCAP_FD_UNIX_SOCK;
+
+
+		//
+		// parse the fields
+		//
+		// 1. Num
+		token = strtok(line, delimiters);
+		if(token == NULL)
+		{
+			ASSERT(false);
+			free(fdinfo);
+			continue;
+		}
+
+		// 2. Eth
+		token = strtok(NULL, delimiters);
+		if(token == NULL)
+		{
+			ASSERT(false);
+			free(fdinfo);
+			continue;
+		}
+
+		// 3. Pid
+		token = strtok(NULL, delimiters);
+		if(token == NULL)
+		{
+			ASSERT(false);
+			free(fdinfo);
+			continue;
+		}
+
+		// 4. Groups
+		token = strtok(NULL, delimiters);
+		if(token == NULL)
+		{
+			ASSERT(false);
+			free(fdinfo);
+			continue;
+		}
+
+		// 5. Rmem
+		token = strtok(NULL, delimiters);
+		if(token == NULL)
+		{
+			ASSERT(false);
+			free(fdinfo);
+			continue;
+		}
+
+		// 6. Wmem
+		token = strtok(NULL, delimiters);
+		if(token == NULL)
+		{
+			ASSERT(false);
+			free(fdinfo);
+			continue;
+		}
+
+		// 7. Dump
+		token = strtok(NULL, delimiters);
+		if(token == NULL)
+		{
+			ASSERT(false);
+			free(fdinfo);
+			continue;
+		}
+
+		// 8. Locks
+		token = strtok(NULL, delimiters);
+		if(token == NULL)
+		{
+			ASSERT(false);
+			free(fdinfo);
+			continue;
+		}
+
+		// 9. Drops
+		token = strtok(NULL, delimiters);
+		if(token == NULL)
+		{
+			ASSERT(false);
+			free(fdinfo);
+			continue;
+		}
+
+		// 10. Inode
+		token = strtok(NULL, delimiters);
+		if(token == NULL)
+		{
+			ASSERT(false);
+			free(fdinfo);
+			continue;
+		}
+
+		sscanf(token, "%"PRIu64, &(fdinfo->ino));
+
+		HASH_ADD_INT64((*sockets), ino, fdinfo);
+		if(uth_status != SCAP_SUCCESS)
+		{
+			snprintf(handle->m_lasterr, SCAP_LASTERR_SIZE, "netlink socket allocation error");
+			return SCAP_FAILURE;
+		}
+	}
+	fclose(f);
+	return uth_status;
+}
+
 int32_t scap_fd_read_ipv4_sockets_from_proc_fs(scap_t *handle, const char *dir, int l4proto, scap_fdinfo **sockets)
 {
 	FILE *f;
@@ -1279,6 +1430,13 @@ int32_t scap_fd_read_sockets(scap_t *handle, char* procdir, struct scap_ns_socke
 		return SCAP_FAILURE;
 	}
 
+	snprintf(filename, sizeof(filename), "%snetlink", netroot);
+	if(scap_fd_read_netlink_sockets_from_proc_fs(handle, filename, &sockets->sockets) == SCAP_FAILURE)
+	{
+		scap_fd_free_table(handle, &sockets->sockets);
+		return SCAP_FAILURE;
+	}
+
 	snprintf(filename, sizeof(filename), "%stcp6", netroot);
     /* We assume if there is /proc/net/tcp6 that ipv6 is avaiable */
     if(access(filename, R_OK) == 0)
diff --git a/userspace/libscap/scap_savefile.c b/userspace/libscap/scap_savefile.c
index 4ce392b23..20b0ff061 100755
--- a/userspace/libscap/scap_savefile.c
+++ b/userspace/libscap/scap_savefile.c
@@ -121,7 +121,8 @@ static int32_t scap_write_proc_fds(scap_t *handle, struct scap_threadinfo *tinfo
 	//
 	HASH_ITER(hh, tinfo->fdlist, fdi, tfdi)
 	{
-		if(fdi->type != SCAP_FD_UNINITIALIZED)
+		if(fdi->type != SCAP_FD_UNINITIALIZED &&
+		   fdi->type != SCAP_FD_UNKNOWN)
 		{
 			totlen += scap_fd_info_len(fdi);
 		}
diff --git a/userspace/libsinsp/event.cpp b/userspace/libsinsp/event.cpp
index aca77c70f..c5b08d26a 100644
--- a/userspace/libsinsp/event.cpp
+++ b/userspace/libsinsp/event.cpp
@@ -2376,6 +2376,7 @@ void sinsp_evt::get_category(OUT sinsp_evt::category* cat)
 					case SCAP_FD_UNSUPPORTED:
 					case SCAP_FD_EVENTPOLL:
 					case SCAP_FD_TIMERFD:
+					case SCAP_FD_NETLINK:
 						cat->m_subcategory = SC_OTHER;
 						break;
 					case SCAP_FD_UNKNOWN:
diff --git a/userspace/libsinsp/fdinfo.cpp b/userspace/libsinsp/fdinfo.cpp
index fc07a0d2b..eba58258b 100644
--- a/userspace/libsinsp/fdinfo.cpp
+++ b/userspace/libsinsp/fdinfo.cpp
@@ -83,6 +83,8 @@ template<> char sinsp_fdinfo_t::get_typechar()
 		return CHAR_FD_INOTIFY;
 	case SCAP_FD_TIMERFD:
 		return CHAR_FD_TIMERFD;
+	case SCAP_FD_NETLINK:
+		return CHAR_FD_NETLINK;
 	default:
 //		ASSERT(false);
 		return '?';
@@ -117,6 +119,8 @@ template<> char* sinsp_fdinfo_t::get_typestring()
 		return (char*)"inotify";
 	case SCAP_FD_TIMERFD:
 		return (char*)"timerfd";
+	case SCAP_FD_NETLINK:
+		return (char*)"netlink";
 	default:
 		return (char*)"<NA>";
 	}
diff --git a/userspace/libsinsp/fdinfo.h b/userspace/libsinsp/fdinfo.h
index 73406ddd8..1b357d596 100644
--- a/userspace/libsinsp/fdinfo.h
+++ b/userspace/libsinsp/fdinfo.h
@@ -42,6 +42,7 @@ class sinsp_protodecoder;
 #define CHAR_FD_EVENTPOLL		'l'
 #define CHAR_FD_INOTIFY			'i'
 #define CHAR_FD_TIMERFD			't'
+#define CHAR_FD_NETLINK			'n'
 
 /** @defgroup state State management 
  * A collection of classes to query process and FD state.
diff --git a/userspace/libsinsp/parsers.cpp b/userspace/libsinsp/parsers.cpp
index 0552ac669..14559a323 100644
--- a/userspace/libsinsp/parsers.cpp
+++ b/userspace/libsinsp/parsers.cpp
@@ -2008,10 +2008,13 @@ inline void sinsp_parser::add_socket(sinsp_evt *evt, int64_t fd, uint32_t domain
 			fdi.m_sockinfo.m_ipv4info.m_fields.m_l4proto = SCAP_L4_ICMP;
 		}
 	}
+	else if (domain == PPM_AF_NETLINK)
+	{
+		fdi.m_type = SCAP_FD_NETLINK;
+	}
 	else
 	{
-		if(domain != 16 &&  // AF_NETLINK, used by processes to talk to the kernel
-		        domain != 10 && // IPv6
+		if(     domain != 10 && // IPv6
 		        domain != 17)   // AF_PACKET, used for packet capture
 		{
 			//
@@ -2021,6 +2024,17 @@ inline void sinsp_parser::add_socket(sinsp_evt *evt, int64_t fd, uint32_t domain
 		}
 	}
 
+	if(fdi.m_type == SCAP_FD_UNKNOWN)
+	{
+		g_logger.log("Unknown fd fd=" + to_string(fd) +
+			     " domain=" + to_string(domain) +
+			     " type=" + to_string(type) +
+			     " protocol=" + to_string(protocol) +
+			     " pid=" + to_string(evt->m_tinfo->m_pid) +
+			     " comm=" + evt->m_tinfo->m_comm,
+			     sinsp_logger::SEV_DEBUG);
+	}
+
 #ifndef INCLUDE_UNKNOWN_SOCKET_FDS
 	if(fdi.m_type == SCAP_FD_UNKNOWN)
 	{
diff --git a/userspace/libsinsp/threadinfo.cpp b/userspace/libsinsp/threadinfo.cpp
index ca8513ed6..b284391f1 100644
--- a/userspace/libsinsp/threadinfo.cpp
+++ b/userspace/libsinsp/threadinfo.cpp
@@ -305,6 +305,7 @@ void sinsp_threadinfo::add_fd_from_scap(scap_fdinfo *fdi, OUT sinsp_fdinfo_t *re
 	case SCAP_FD_EVENT:
 	case SCAP_FD_INOTIFY:
 	case SCAP_FD_TIMERFD:
+	case SCAP_FD_NETLINK:
 		newfdi->m_name = fdi->info.fname;
 
 		if(newfdi->m_name == USER_EVT_DEVICE_NAME)
@@ -968,6 +969,7 @@ void sinsp_threadinfo::fd_to_scap(scap_fdinfo *dst, sinsp_fdinfo_t* src)
 	case SCAP_FD_EVENT:
 	case SCAP_FD_INOTIFY:
 	case SCAP_FD_TIMERFD:
+	case SCAP_FD_NETLINK:
 		strncpy(dst->info.fname, src->m_name.c_str(), SCAP_MAX_PATH_SIZE);
 		break;
 	default:
