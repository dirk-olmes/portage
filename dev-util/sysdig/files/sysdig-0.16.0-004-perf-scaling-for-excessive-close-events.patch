From 3a6f62da0dd651b11c3aa222310dc5ef88699b8e Mon Sep 17 00:00:00 2001
From: Brett Bertocci <brett@sysdig.com>
Date: Mon, 5 Jun 2017 15:02:44 -0700
Subject: [PATCH] Perf scaling for excessive close() events (#852)

* Drop close() exit events with error returns

For the agent, we don't need to process close() events where an error
occurred because they won't affect our fd tracking. Drop these events
early so we don't take a perf hit from superfluous but valid close() calls.

* Drop close() events early

This avoids locking the consumer(s) and a getnstimeofday() call

* Drop close() enter events

If the close fd is invalid or not open, drop the enter event because
it will have no side effects on the agent.

* code cleanup

* Restrict close() drop logic to the agent + code cleanup

* Add support for kernels older than 3.4.x

* Address review comments

* Don't process close() events with negative fd

* Handle negative fd values correctly
---
 driver/main.c | 51 +++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 49 insertions(+), 2 deletions(-)

diff --git a/driver/main.c b/driver/main.c
index 3f9762caa..e74323836 100644
--- a/driver/main.c
+++ b/driver/main.c
@@ -49,6 +49,7 @@ along with sysdig.  If not, see <http://www.gnu.org/licenses/>.
 #include <linux/tracepoint.h>
 #include <linux/cpu.h>
 #include <linux/jiffies.h>
+#include <linux/fdtable.h>
 #include <net/sock.h>
 #include <asm/asm-offsets.h>	/* For NR_syscalls */
 #include <asm/unistd.h>
@@ -1275,8 +1276,53 @@ static inline void record_drop_x(struct ppm_consumer_t *consumer, struct timespe
 	}
 }
 
-static inline int drop_event(struct ppm_consumer_t *consumer, enum ppm_event_type event_type, enum syscall_flags drop_flags, struct timespec *ts)
+static inline int drop_event(struct ppm_consumer_t *consumer,
+			     enum ppm_event_type event_type,
+			     enum syscall_flags drop_flags,
+			     struct timespec *ts,
+			     struct pt_regs *regs)
 {
+	unsigned long close_arg = 0;
+	int close_fd = -1;
+	struct files_struct *files;
+	struct fdtable *fdt;
+	bool close_return = false;
+
+	/*
+	 * It's annoying but valid for a program to make a large number of
+	 * close() calls on nonexistent fds. That can cause driver cpu usage
+	 * to spike dramatically, so drop close events if the fd is not valid.
+	 *
+	 * The invalid fd events don't matter to userspace in dropping mode,
+	 * so we do this before the UF_NEVER_DROP check
+	 */
+	if (consumer->dropping_mode) {
+		if (event_type == PPME_SYSCALL_CLOSE_X) {
+			if (syscall_get_return_value(current, regs) < 0)
+				close_return = true;
+		} else if (event_type == PPME_SYSCALL_CLOSE_E) {
+			syscall_get_arguments(current, regs, 0, 1, &close_arg);
+			close_fd = (int)close_arg;
+
+			files = current->files;
+			spin_lock(&files->file_lock);
+			fdt = files_fdtable(files);
+			if (close_fd < 0 || close_fd >= fdt->max_fds ||
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0))
+			    !FD_ISSET(close_fd, fdt->open_fds)
+#else
+			    !fd_is_open(close_fd, fdt)
+#endif
+				) {
+				close_return = true;
+			}
+			spin_unlock(&files->file_lock);
+		}
+
+		if (close_return)
+			return 1;
+	}
+
 	if (drop_flags & UF_NEVER_DROP) {
 		ASSERT((drop_flags & UF_ALWAYS_DROP) == 0);
 		return 0;
@@ -1355,7 +1401,8 @@ static int record_event_consumer(struct ppm_consumer_t *consumer,
 		else if (consumer->need_to_insert_drop_x == 1)
 			record_drop_x(consumer, ts);
 
-		if (drop_event(consumer, event_type, drop_flags, ts))
+		if (drop_event(consumer, event_type, drop_flags, ts,
+			       event_datap->event_info.syscall_data.regs))
 			return res;
 	}
 
